* * * * *

**Структура директорий:**

-   **./lib** - исходники модулей и классов, написанных для решения задач;
-   **./readme** - набор markdown-файлов с ответами на вопросы;
-   **./scripts** - исходники решений задач;
-   **./spec** - спеки для задач LVL2\_Q5 и LVL2\_Q6

* * * * *

Все вопросы по отдельности:

-   LEVEL 1

    -   [Q1: Какие сторонние библиотеки вы используете чаще всего для разработки. Какие плюсы в них вы выделяете для себя?](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl1_q1.md)
    -   [Q2. При работе в команде, каким бы местам в разработке вы бы уделили большее внимание? Какие бы соглашения (Coding Conventions) вам бы помогли в командной разработке?](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl1_q2.md)
    -   [Q3. Вы когда-нибудь писали в функциональном стиле на Ruby? Если да, то какие сильные и слабые стороны есть у данного подхода?](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl1_q3.md)
    -   [Q4. Расскажите об используемых Вами фреймворках (программных каркасах). В чем их плюсы? Для каких задач лучше использовать существующий фреймворк, а когда лучше все написать самому?](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl1_q4.md)
    -   [Q5. Какие инструменты для профайлинга и дебага вы используете? Какие у них минусы? Какие продукты вы использовали для профайлинга и дебага сетевых приложений?](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl1_q5.md)
    -   [Q6. Какие плюсы и минусы есть у системы обработок ошибок в Ruby?](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl1_q6.md)
    -   [Q7. На каких языках программирования вы дополнительно пишите код?](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl1_q7.md)
-   LEVEL 2

    -   [Q1. Объясните почему происходит следующее](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl2_q1.md)
    -   [Q2. Нужно написать прослойку между почтовым сервером и front-end приложением (Flash AS3 Application). Опишите следующие моменты:](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl2_q2.md)
    -   [Q3. Объясните в чем разница в использовании тредов (threads) и форков (forks). В каких случаях, какой вариант более предпочтительный для использования? Как можно профилировать и проводить дебаг приложений с использованием тредов?](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl2_q3.md)
    -   [Q4. Расскажите как можно организовать работу кода в Ruby в асинхронном режиме?](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl2_q4.md)
    -   [Q5. Напишите скрипт grab.rb принимающий на вход 2 параметра, например так: ./grab.rb 'www.google.com' /tmp](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl2_q5.md)
    -   [Q6. Покройте код предыдущей задачи тестами (плюсом будет использование rspec).](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl2_q6.md)
-   LEVEL 3

    -   [Q1. У вас есть массив целых чисел. Все числа идут последовательно от 1 до k. Но в массиве пропущены 2 числа. Реализуйте алгоритм для нахождения этих чисел.](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl3_q1.md)
    -   [Q2. Какие нюансы в работе виртуальной машины Ruby вы знаете? Какие оптимизации над кодом можно произвести для ускорения его выполнения?](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl3_q2.md)
    -   [Q3. Привести пример максимально быстрого алгоритма](https://github.com/tasksfromfb/tffb/blob/master/readme/lvl3_q3.md)

* * * * *

### LEVEL 1

* * * * *

#### Q1: Какие сторонние библиотеки вы используете чаще всего для разработки. Какие плюсы в них вы выделяете для себя?

* * * * *

Примечание: по большей части, сейчас будет идти выжимка из Gemfile'ов с некоторыми комментариями; большинство из всех гемов - rails oriented (за исключением секции in the wild), т.к. в основном писал под Rails.
В своем обучении (тобишь что изучаю до сих пор) и в повседневной разработке пользуюсь следующим набором библиотек и фреймворков (некоторыми пользовался лишь однажды, некоторыми пользуюсь постоянно):

###### Wild Libs

-   [Nokogiri](nokogiri) - парсинг web-страниц;
-   [Ruby ProgressBar](ruby-progressbar) - прогресс-бар для консольных приложений;
-   [Addressable](addressable) - решение проблем стандартной либы URI (URI::Generic'и сломали мне голову, когда я использовал URI вместе с open-uri, умеет эвристически собирать url'ки на базе неполных данных (нет порта, нет схемы и т.п.));
-   [open-uri-redirecions](open_uri_redirections) - поддержка автоматических редиректов http \<=\> https;
-   [EventMachine](https://github.com/eventmachine/eventmachine),[em-websockets](https://github.com/igrigorik/em-websocket) - писал очень простой пример приложение-чата на вэбсокетах. Под капотом крутились эти гемы для имплементации простенького вэбсокет-сервиса.
-   [Benchmark](http://ruby-doc.org/stdlib-1.9.3/libdoc/benchmark/rdoc/Benchmark.html) - определение времени выполнения блока кода. Удобно, когда нужно проследить, сколько времени выполняется часть вашего кода, что может помочь в оптимизации кода, или намекнуть, что пора бы здесь что-то порефакторить.
-   [ruby-prof](https://github.com/ruby-prof/ruby-prof) - только пробовал, очень интересный профилировщик, помощнее стандартного -r profile. Воспользовался бы в будущем.

###### Frameworks

-   [Ruby on Rails](https://github.com/rails/rails) - мэйнстрим в Ruby-тусовке среди Web-разработчиков. All-in Web-Framework;
-   [Sinatra](https://github.com/sinatra/sinatra) - легковесный micro-web-framework, который очень удобен для написания RESTful API. Естественно, способен на большее. Я его позиционирую как нечто вроде ExpressJS из мира NodeJS, или (идеологически) как BackboneJS для создания собственных web-framework'ов (и не только). Иногда пользуюсь, когда нужно что-то быстренько запрототипить;

###### Testing tools, libraries and frameworks

-   [RSpec](http://rspec.info/) - стандарт де-факто в тестировании приложений, написанных на Ruby;
-   [JSON Schema Validator](https://github.com/ruby-json-schema/json-schema) - встала проблема (или идея) как тестировать JSON-ответы на их структуру. Чувствовал, есть DRY-способы, и более продвинутые, чем простое .to\_s и .include?. В поисках решения нашел вот такую интересную библиотеку, которую можно интегрировать в тесты, написав кастомный матчер. Очень удобная вещь и, я бы даже сказал, must have;
-   [Factory Girl](https://github.com/thoughtbot/factory_girl) - генерация данных для тестов. Must have. Использую как замена стандартным RoR-фикстурам;
-   [Database Cleaner](https://github.com/DatabaseCleaner/database_cleaner) - юзаю для управления поведением транзакций и очистки базы данных в тестах Ruby on Rails приложений;
-   [MiniTest](https://github.com/seattlerb/minitest) - хороший фрэймворк для тестирования приложений на Ruby. Встроен в Ruby, использовал при первом знакомстве с Ruby on Rails;
-   [Capybara](https://github.com/jnicklas/capybara) - integration-тесты для ваших web-приложений. Must-have (selenium-webdriver берем под мышку :))
-   [Minitest reporters](https://github.com/kern/minitest-reporters) - библиотечка-расширение для MiniTest. Когда-то использовал при тестировании Rails-приложений. Удобно минифаит и бьютифаит console output.

###### Automation toolkits

-   [Rubocop](https://github.com/bbatsov/rubocop) - статический анализатор кода. Использую для слежки за очевидными ошибками в форматировании кода, а так же он работает как мой 'CodeStyle-полицейский';
-   [Guard](https://github.com/guard/guard) - тулкит для автоматизации задач. Пробовал использовать для автоматического запуска тестов и syntax checking'а различных языков. Отказался от использования именно в этом направлении, т.к. считаю, что синтаксис должны проверять IDE/TextEditor, а запуск тестов я запускаю ручками сам, т.к. когда тестов много, или когда вы очень часто сэйвите файл (как я), Guard доставит вам много Overhead-хлопот (в бонус к радостям жизни).

###### Libraries

-   [Faker](https://github.com/stympy/faker) - генератор случайных данных (names, dates, emails, texts, etc.). Использую, когда надо наполнить данными web-приложения для имитации их работы in the wild;

###### Rails based libraries

-   [Devise](https://github.com/plataformatec/devise) - организации функционала аутентификации пользователей на сайте. Must have;
-   [Devise-Token-Auth](https://github.com/lynndylanhurley/devise_token_auth) - реализация гема Devise для Rails JSON API based приложений. Must have;
-   [Meta Request](https://github.com/dejan/rails_panel/tree/master/meta_request) - debug-библиотека для Rails-приложений, которая работает в паре с соответствующим [Rails Panel](https://github.com/dejan/rails_panel)-CrhomeExtention. Юзаю для дебага RoR-приложений (смотрим, какой контроллер отвечает, какие данные пробрасываюстя, какие модели хватаются, сколько по времени всё занимает, etc.);
-   [Responders](https://github.com/plataformatec/responders) - набор respond-методов для контроллеров. Пробовал использовать, чтобы по-DRY-ить код, свернув конструкцию respond\_to=\>format=\>render до глобального respond\_to и сахарного respond\_with, но мне очень нужен был Control flow в respond\_to, поэтому пока не использую;
-   [Stronger Parameters](https://github.com/zendesk/stronger_parameters) - type checking и type casting в permit-методах контроллеров. Когда встала в этой либке? Ситуация следующая: есть модель, у неё есть поле, которое представляет собой некое состояние и базируется на множестве Integer-значений, представляя собой ActiveRecord enum-поле (чтобы можно было осмысленно отразить каждое значение на некое текстовой поле). Мне нужен был автоматический каст (DRY DRY DRY :)) этих значений из текстового представления от frontend'а в integer-представление моей модели. Очень удобно.
-   [Rails ERD](https://github.com/voormedia/rails-erd) - генератор Entity Relationship Diagrams на основе моделей ActiveRecord. Когда моделей в проекте становится очень много, а связей между ними - несусветное множество, этот гем позволяет визуализировать ваши связи в отдельный файл (хотя, там тоже будет нехилый такой бардачок, но анализировать его на каком-нибудь экране проектора очень удобно);
-   [CarrierWave](https://github.com/carrierwaveuploader/carrierwave) - хэндлер загрузки файлов для Web-фреймворков;
-   [Browserify-Rails](https://github.com/browserify-rails/browserify-rails) - использовал однажды, когда пробовал подключить интересный ReactJS-фреймворк [Material-UI](https://github.com/callemall/material-ui) напрямую к рельсам из npm. Не Rails-Way, не использую больше;
-   [MiniMagick](https://github.com/minimagick/minimagick) - обработка изображений, wrapper для ImageMagick/GraphicsMagick.
-   [Better Errors](https://github.com/charliesome/better_errors) - замена стандартной страницы ошибки на более информативную (интересная фича: вывод части кода файла с подсветкой строки, где произошла ошибка)

###### Frontend frameworks integration for Rails

-   Примечание: возможно, стоит отказаться от сборки ассэтов через Asset Pipeline и отдать эту прерогативу Webpack'у, т.к. в этом плане он намного круче и мощнее;
-   [Haml](https://github.com/indirect/haml-rails) - интеграция шаблонизатора Haml в RoR. больше не использую из-за невозможности инлайнить многие вещи в простой текст (особенно раздражают сумасшедшие лестницы из текст-тэг-текст, когда необходимо заинлайнить html в текст). В свящи с этим перешел на Slim;
-   [Slim](https://github.com/slim-template/slim-rails) - интеграция шаблонизатора Slim в RoR. Решил проблемы Haml'а. Понравился бонус из подмешиваемого HTML в Slim-файл. Если надо что-то потестить быстро (какой-нибудь банальный ctrl-c ctrl-v сырого html-кода) - эта фича спасает);
-   [Material Design Lite](http://www.getmdl.io/) - интеграция frontend-фрэймворка Material Design Lite;
-   [Material Design Icons](https://github.com/Angelmmiguel/material_icons) - material design style icons;
-   [Twitter Bootstrap](bootstrap-sass) - интегрируем Frontend TwitterBootstrap Framework в RoR;
-   [FontAwesome](font-awesome-sass) - интеграция иконок FontAwesome в проекты на RoR;
-   [will\_paginate](will_paginate) - пагинация для коллекций ActiveRecord моделей;
-   [Authoprefixer](autoprefixer-rails) - спасает жизнь от горы vendor-css-миксинов в SASS, интегрится в Rails Assets Pipeline;
-   [Fluxxor](http://fluxxor.com/) - интеграция JS-библиотеки Fluxxor в RoR-проекты (сейчас изучаю Flux-методологию во frontend-разработке, пригляделась эта библиотечка, реализующая эту методологию);
-   [ReactJS](https://facebook.github.io/react/) - интеграция JS-библиотеки React в RoR-проекты (начал изучать ReactJS, понадобилась интеграция в RoR. интересна, наверно, по большей части своими возможностями рендеринга на backend'e);
-   [ReactRouter](https://github.com/rackt/react-router) - интеграция JS-библиотеки ReactRouter в RoR-проекты (интересовало, как реализовать роутинг на ReactJS, приглянулась эта либка, пока не пробовал еще, но оставил себе на заметку)

* * * * *

#### Q2. При работе в команде, каким бы местам в разработке вы бы уделили большее внимание? Какие бы соглашения (Coding Conventions) вам бы помогли в командной разработке?

* * * * *

1.  Методология разработки (вникал только в SCRUM).
2.  Выбор тулсэта: Version Control System, Bug tracker, Task Manager, Continuous Integration Tools, Server Stacks;
3.  Разделение ответственностей (для junior'ов - наставники + однозначно необходим teamlead (senior level) и разбирающийся в выбранной предметной области менеджмент);
4.  Code Conventions:

    -   **Project Directory Structure**: в зависимости от проека / согласно best practics;
    -   **Ruby**: [Ruby Style Guide](https://github.com/arbox/ruby-style-guide/blob/master/README-ruRU.md); **Rails**: [Rails Style Guide](https://github.com/arbox/rails-style-guide/blob/master/README-ruRU.md); **Commenting**: [YARDoc](http://yardoc.org/) (предпочитаю его, похож на JSDoc, удобно и приятно) / RDoc;
    -   **JavaScript**: Airbnb Code Style Guides ([JavaScript](https://github.com/airbnb/javascript), [React](https://github.com/airbnb/javascript/tree/master/react), [CSS](https://github.com/airbnb/css)); **Commenting**: [JSDoc](https://github.com/jsdoc3/jsdoc) (но не факт, что именно этми конвеншнами воспользуюсь, т.к. не так много опыта написания кода на JS);

* * * * *

#### Q3. Вы когда-нибудь писали в функциональном стиле на Ruby? Если да, то какие сильные и слабые стороны есть у данного подхода?

* * * * *

В функциональном стиле особо (за исключением повсеместного использования блоков и местами lambda) не писал (только пробовал, когда вникал в эту тему). Почитал об этом в различных статьях на habrahabr и Wikipedia, а так же немного в книгах, и могу сказать следующее:

В отношении Ruby:

-   Ruby почти повсеместно использует свойство функционального программирования - это функции высшего порядка (блоки кода, передаваемые функции как параметр и выполняемые через инструкцию yield) (proc, lambda).
-   Слабая сторона, наверно, только в неочевидности алгоритмов кода (мозг привык думать императивно/декларативно + различное поведение return у proc, lambda и method могут породить неочевидные поведения функций).
-   Сильная сторона: поддержка функционального стиля программирования как такового (хоть и частичная, т.к. Ruby - ООП-язык; возможность дополнять / изменять алгоритмы работы методов за счет блоков (proc / lambda / method), которые играют роль callback-функций в таком контексте; поддержка ленивых вычислений (lambda, proc)).

Преимущества функционального подхода в целом для программирования:

-   отладка: т.к. состояние впринципе неизменяемое, а функции - чистые и без побочных эффектов, можно легко локализовать проблему на основе аргументов и реализации функции;
-   многопоточность / асинхронность: нет mutex'ов (т.к. нет разделяемого состояния) =\> можно легко распаралеллить выполнение функций;
-   оптимизация за счет ленивых вычислений: например, когда мы вычисляем одну функцию функцию, зависящую от результатов выполнения (допустим, двух предыдущих вызовов других функций, который выполняются только вместе с нашей первой функцией), умный компилятор поймет, что выполнять вычесления этих двух функций нужно только на этапе обращеня к ним в последней функции, в которй они выполняют роль параметров (отсюда преимущество в функциях высшего порядка).

Недостатки функционального подхода в целом для программирования:

-   чистота функций: в программах очень часто необходимо работать, изменяя внешнее состояние (например, консольное приложение, выводящая результаты на экран), а функции в этих программах при одних и тех же входных параметрах могут возвращать различные значения из-за непостоянного внешнего состояния. Исхитрение: гнать состояние от функции к функции;
-   т.к. функции чистые, мы не имеем возможности организовать последовательность их вычислений (если компилятор умный =\> он распараллелит их выполнение), но можно исхитриться передачей функций как параметров (правда, получив при этом callback hell).

В отношении функционального подхода в целом, пока основными плюсами для себя выделил чистые функции, функции высшего порядка и ленивые вычисления.
Минус пока вижу в постоянных "играх с памятью": при копировании и удалении состояний (параметров функций) нужнен эффективный Garbage Collector, который хорошо бы справлялся с постоянным выделением и очисткой памяти ИЛИ (там где нет автоматического сборщика мусора) самому грамотно следить за тем, чтобы память "не текла".

* * * * *

#### Q4. Расскажите об используемых Вами фреймворках (программных каркасах). В чем их плюсы? Для каких задач лучше использовать существующий фреймворк, а когда лучше все написать самому?

* * * * *

Из полноценных фрэймворков я пользовался Ruby on Rails, Sinatra и RSpec. Ruby on Rails / Sinatra - разработка web-сервисов/web-приложений. RSpec - фрэймворк, предназначенный для тестирования приложений, написанных на Ruby.
Плюсы ***Rails*** скорее в том, что почти всё из области разработки Web-приложений - *'из коробки'* (назову некоторые из них):

-   Convention over Configuration (bestpractics уже изучены и жёстко вшиты в фрэймворк, разрабатывая на Rails чаще всего вы не будете иметь особых проблем, когдая включаетесь в новый для себя проект);
-   прозрачний live-reload кода при разработке;
-   множество enviroment'ов (production / testing / develompent из коробки);
-   логгирование (приятно наблюдать в development в консоли realtime-логи sql-запросов от ActiveRecord'ов);
-   кодогенерация (для себя выделяю удобство в controller / model / migrations / specs);
-   ресурсный роутинг (маппинг url на контроллеры без головной боли за реализацию);
-   в счет своей популярности, имеет хорошую поддержку различными редакторами кода (RubyMine очень хорошо подхватывает проекты на RoR; например: имеет плагин, позволяющий вывести список роутов с их шаблонами в отдельном окне, а по двойному клику - перейти в место в коде соответствующего контроллера);
-   background tasks (пока не пользовался, только немного читал (ActiveJob (Sidekiq)), но выделю это для себя как отдельный плюс, т.к. грамотный подход к работе с фоновыми задачами приживается рельсами своей собственной реализацией);
-   DRY всего, что можно, и пропаганда этого по максимуму (от чего множество типовых задач уже решены и доступны в виде гема или плагина);

Конечно, если Rails чем-то не устраевает или не отвечает вашим требованиям, можно воспользоваться Sinatra. Sinatra позиционирую для себя как framework для конструирования своего кастомного комбайна (аля ArchLinux или BackboneJS).

***RSpec*** - тестирование приложений, написанных на Ruby. Из плюсов для себя выделяю:

-   лаконичный DSL - describe / context / it / expect;
-   большое количество матчеров (to be, to change, not\_to, eq, etc);
-   расширяем (возможно написание своих собственных матчеров);
-   в виду своей вездесущности и de-facto-стандартности, реализована поддержка интегрируемости почти во всё, что можно (с соответствующими матчерами);
-   lazy-loading тестовых данных с их кешированием (let);

Когда следует использовать существующий фреймворк, а когда - свою собственную реализацию:

-   необходимо сэкономить время на реализацию продукта - **используем существующий framework**.
-   архитектура проекта очевидна и стандартна, когда ваш набор требований к продукту покрывается конкретным фреймворком - **используем существующий framework**.
-   необходимо реализовывать часто используемую фичу (наример, работу со временем) - **используем существуюю библиотечку, иначе - своя реализация**.
-   необходимо реализовать какую-либу фичу под определенную для вашего проекта архитектуру - **пишем свою реализацию (или ищем какую-нибудь библиотечку) или думаем о дополнениях для уже выбранного framework'а**.
-   существующие фреймворки не способены ответить некоторым вашим требованиям / задачам - **подумать, реализовать для выбранного фрэймворка плагин или всё таки написать свое решение**.
-   необходимо реализовать функционал, который имеется как отдельная фича в различных фрэймворках - **посмотреть, возможно ли ею воспользоваться как модуль, впишется ли она в ваш проект и архитектуру**.
-   пишем какой-то коммерческий код и лицензия framework'а не вписывается в вашу лицензию, или когда пишем проприетарный продукт - **пишем свою реализацию**.
-   реализация фреймворка не покрыта тестами, код сомнителен, у фреймворка нет хорошего community и support, git не обновлялся 200 лет - **пишем свою реализацию**.
-   вы видите во всём новом абсолютный hype и вы code hipster - **юзаем все фреймворки, которые слышим на конференциях и пихаем их везде, до куда долезут руки**.

* * * * *

#### Q5. Какие инструменты для профайлинга и дебага вы используете? Какие у них минусы? Какие продукты вы использовали для профайлинга и дебага сетевых приложений?

* * * * *

О минусах пока не могу особо судить, т.к. не так много опыта в работе с таким инструментарием (не часто дебажу и профайлю). Скажу лишь о том, что я использовал:

***Профайлинг и дебаг***:

-   **Benchmark** для определения, сколько времени потрачено на выполнение метода или программы в целом;
-   **-r profile** для оценки работы моих методов по времени;
-   **RubyMine IDE Debugger**: в RM очень удобный интерактивный дебаггер с классным инструментарием;
-   **.inspect**: быстро проверить, что хранит какой-либо объект;
-   **byebug** - только пробовал, когда смотрел, как пользоваться этим дебаггером, хороший полноценный консольный дебаггер.

***Особо не пользовался, но воспользовался бы в будущем***:

-   **ruby-prof** - особо не пользовался, но очень хоорошая тулза для профайлинга как замена стандартному -r profile;
-   **gem [gc\_tracer](https://github.com/ko1/gc_tracer)** - для подхвата событий GC и трассировки его вызовов;
-   **множество nix-tools** (например, простой мониторинг памяти процессов или просмотр системных вызовов во время выполнения вашей программы).

Для профайлинга утечек памяти воспользовался бы следующими ruby-гемами и методами некоторых библиотек: GC::Profiler, gc\_tracer, ObjectSpace, GC.start / GC.stat. Конечно, есть еще полноценные тулкиты для профилирования процессов и памяти, но я пока не занимался их изучением.

***Сетевые приложения***:

-   **Wireshark**: когда-то давно смотрел на то, какие запросы и ответы генерируют приложения на низком уровне. Воспользовался бы для дебага сетевого приложения;
-   **nmap**: проверить работу своего сервиса извне, хотя этот инструмент способен на большее;
-   **curl**: собрать кастомный сетевой запрос;
-   **Advanced REST Client (Chrome Extention)**: удобно работать с REST API и тестировать его;
-   **MailCatcher**: легкий SMTP-сервер с вэб-интерфейсом, удобно быстро обрабатывать и просматривтаь письма, генерируемые приложением во время разработки
-   Для Security-тестов можно воспользоваться **Burp Suite** и **Metasploit** (пробовал только **Metasploit**).

#### Q6. Какие плюсы и минусы есть у системы обработок ошибок в Ruby?

* * * * *

Скажу о плюсах, т.к. пока не вижу минусов O.O. Тематика для дискаса на наводящих вопросах, я думаю, т.к. пока не моуг придумтаь проблемную ситуацию.

-   ensure - выражение, которое всегда выполняется перед возвращением значения;
-   иерархическая структура исключений с предопределенными типами ислкючительных ситуаций;
-   простота генерации исключения (raise 'message' - и получили Runtime Error);
-   простота обработки исключений (rescue [ExceptionType, ExceptionType, ...] =\> exception\_object);
-   конструкция else - выполняется, если в основном блоке не было вызвано исключеий
-   возможность работать с исключенями в потоках (метод класса и экземпляра abort\_on\_exception) и всплытие исключений из потоков при вызове у потока .join или .value

* * * * *

#### Q7. На каких языках программирования вы дополнительно пишите код?

* * * * *

-   **UML** - (отнесу его к языкам) в основном диаграмы классов и немного Sequence и Activity;
-   **SQL** - работа с базами данных MySQL, PostgreSQL (уже давно не писал ни триггеров, ни функций, но было дело);
-   **JavaScript** - только frontend (в данный момент по-немногу погружаюсь в EcmaScript2015 (еще пробовал CoffeeScript (RoR пытался меня заставить), но считаю его мёртвым языком)), хотя пробовал и backend (очень простое NodeJS-приложение для прозрачной работы с лентой в Twitter и Vkontakte);
-   **HTML(Slim), CSS(SASS)** - frontend;
-   Ранее писал (но не могу сказать, что в них я хорошо разбираюсь): **php, c\#, c++**.

* * * * *

### LEVEL 2

* * * * *

#### Q1. Объясните почему происходит следующее:

1.  1660 / 100 ≠ 16.6
2.  24.0 \* 0.1 ≠ 2.4

* * * * *

##### 1660 / 100 ≠ 16.6

Оператор деления смотрит на типы операндов. Если оба операнда представляют собой целые недробные числа, результат деления будет усечен до целого числа (дробная часть отбрасывается). Решение проблемы: представить хотябы один из операндов дробным числом.

##### 24.0 \* 0.1 ≠ 2.4

Компьютерные числовые операции выполняются в двоичной системе счисления. Некоторые дробные числа невозможно представить точным двоичным числом (0,1 в десятичной системе счисления = 0,0001(1001) в периоде)

Поэтому, в данном случае, на самом деле, мы оперируем приближенным значением 0.1 в операции умножения. В Ruby двоичная арифметика представлена стандартом IEEE-754, и этот стандарт грешит описанной рпоблемой.

То есть: **24.0** = *11000*,0; **0.1** = *0.00011001100*

В зависимости от точности приближенного значения 0.1 (возмем до 12 знака), получаем

~~~~ {.ruby}
*11000* x *0.000110011001* = **10.011001011**
*24.0*  x *0.1* = **2.396484375**
~~~~

***Решение***: если проводятся операции в десятичной системе счисления, следует воспользоваться типом BigDecimal. Или: проводить вычисления с точностью до определенного количества знаков.

* * * * *

#### Q2. Нужно написать прослойку между почтовым сервером и front-end приложением (Flash AS3 Application). Опишите следующие моменты:

* * * * *

Ответить максимально компетентно не могу, т.к. не имею опыта работы с высоконагруженными проектами (а, следовательно, не могу сказать о работе выбранных мною технологий под высокой нагрузкой), но предложу следующий вариант:

###### Какой формат обмена данными вы бы использовали, для минимального трафико-обмена?

-   либо: RESTful + JSON (строим RESTful API) over HTTP;
-   либо: WebSocket + собственный формат данных.

###### В чем плюсы выбранного вами формата?

Если это RESTful JSON:

-   очевидный маппинг над HTTP: для браузеров и других сетевых приложений мы можем формировать наш JSON-ответ попутно основываясь на коде вхоядщего и исходящего HTTP-запроса. Это удобно и очевидно для других разработчиков;
-   почти для всех современых языков программирования уже написано множество библиотек для работы с JSON;
-   легко масштабируемый и расширяемый подход: наше API лигко менять, легко расширять, а когда необходимо резко сменить функционал - мы можем на том же уровне просто написать другую вариацию API под другими URL;
-   почему не SOAP/XML? преимущества вижу в большей компактности данных (а, следовательно, меньше траффика) и в удобстве работы с ними;
-   AS3 имеет неплохую (судя по документации) поддержку работы с JSON.

Если это WebSockets

-   у нас здесь развязаны руки, и мы можем представлять данные и работать с ними с абсолютно любым подходом.

###### Какие бы технологии вы использовали?

Я бы воспользовался:

-   либо NodeJS + ExpressJS, т.к. NodeJS хорошо себя показывает как web-server под высокими нагрузками (исходя из статей, говорящих о том, что NodeJS способен обрабатывать огромное количество сетевых запросов за единицу времени ввиду асинхронности JavaScript'а). Я бы много поразбирался над этими технологиями и изучил имеющиеся решения, т.к. асинхронность JavaScript - привлекательная штука для сетевых приложений.
-   либо Sinatra - удобно строить JSON API ввиду его подхода к определению набора endpoint'ов в виде списка методов, и, к томуже, довольно lightweight-framework по сравнению с Ruby on Rails.
-   либо Ruby on Rails - всё есть из коробки, для написания API-приложений можно воспользоваться [rails-api](https://github.com/rails-api/rails-api).
-   либо своя реализация - например, на EventMachine и em-websocket.

Для сервера я бы воспользовался либо Nginx/Passenger, либо Puma/Unicorn на Nginx (если это Ruby-приложение). Но что именно - затрудняюсь сказать, т.к. не имею достаточного опыта работы с ними.

* * * * *

#### Q3. Объясните в чем разница в использовании тредов (threads) и форков (forks). В каких случаях, какой вариант более предпочтительный для использования? Как можно профилировать и проводить дебаг приложений с использованием тредов?

* * * * *

Форк - это процесс, запущенный как дочерний текущему процессу. Некое подобие ветвления выполнения программы.

-   выполняется в собственном адресном пространстве.
-   начальное состояние дочерний процесс копирует у родительского процесса на момент своей инициализации.
-   не имеет доступа к состоянию родительского процесса: для этого придется подумать о системе коммуникаций между процессами (например, подхватить stdin/stdout/stderr дочернего процесса из родительского).
-   Форк имеет природу процесса, а, значит, в конце своей работы возвращает только код завершения, который, согласно UNIX-соглашению, равен 0, если процесс завершился успешно, и любое отличное от нуля значение, когда процесс завершился с ошибкой.
-   В Ruby форки возвращают pid, а модуль Process может вернуть pid и статус завершения. В Ruby мы можем завершать процесс методоам kill/exit (всё присущее ruby-программам) или приостанавливать работу процесса методом sleep.
-   Дождаться завершения процесса можем с помощью метода модуля Process: Process.wait.

Тред (поток) - блок кода, выполняемый в конексте текущего процесса "асинхронно". Имеет общее состояние между всеми потоками в рамках процесса, в котором они запущены, и, следовательно, коммуникацию между потоками проще организовывать.

-   Треды, в отличие от форков, по своему заверщению способны возвратить состояние.
-   В Ruby имеется возможность обращаться к значениям объекта треда в стиле хэша (если тред установил эти значения), или получить выходное значениее методом Thread.value.
-   В Ruby мы можем управлять ходом выполнения потоков методами stop/sleep/wakeup/run/raise/exit/join.

В каких случаях какой вариант более предпочтительней?

-   Треды удобны для распараллеливания некого куска кода для ускорения работы метода в целом, когда имеется возможность выполнять некоторые шаги алгоритма независимо от выполнения последующих шагов, или когда часть алгоритма выполняется в цикле, и процесс в таком случае можно распараллелить, если каждый шаг цикла атомарен по отношению к следующему.
-   Форки удобно использовать, когда нам нужно запустить какой-то скрипт как отдельном процесс, и когда мы именно этого хотим. Процесс будет диспетчиться системой, а значит, у процесса все характеристики реальных процессов, обрабатываемых системой (по своему выделяется память, по своему диспетчится диспетчером процессов, etc). Также, возможно удобно в интеграционных тестах (воспользовался таким подходом, когда тетсировал программу из следующих вопросов).

Я не дебажил приложения, написанных с использованием потоков, но знаю, что можно воспользоваться гемом byebug, который позволяет дебажить потоки, а также встроенный дебаггер RubyMINE тоже позволяет работать с потоками.

* * * * *

#### Q4. Расскажите как можно организовать работу кода в Ruby в асинхронном режиме?

* * * * *

-   Воспользоваться потоками и процессами;
-   Воспользоваться ленивыми вычислениями (проки и лямбды);
-   Воспользоваться паттернами проектирования Observer, Promise и Future (к сожалению, имею мало познаний в паттернах, но стараюсь сейчас заполнять этот пробел);
-   Можно воспользоваться библиотекой [Concurrent Ruby](https://github.com/ruby-concurrency/concurrent-ruby), которая реализует множество идей асинхронного программирования. Пока не пользовался, но в будущем обязательно буду.

* * * * *

#### Q5. Напишите скрипт grab.rb принимающий на вход 2 параметра, например так: ./grab.rb 'www.google.com' /tmp

-   Скрипт должен скачать все картинки, содержащиеся на странице, указанной первым параметром, в папку, указанную вторым параметром;
-   Скрипт может использовать модули, находящиеся в той же папке, что и сам скрипт;
-   Дополнительные условия: скрипт должен максимально загрузить доступный канал и отрабатывать как можно быстрее.

* * * * *

Алгоритм работы скрипта прост:

1.  взять параметры из консоли;
2.  создать папку, куда будут сохраняться файлы, если её нет;
3.  спарсить все изображения и ссылки на них;
4.  отбросить битые ссылки и ссылки с mime-типами, не соответствующие изображениям;
5.  скачать изображения по оставшимся ссылкам.

Для работы скрипта из консоли я добавил возможность передачи ему параметров:

-   **-u (--uri) uri** - ссылка на страницу, откуда нужно сграббить изображения;
-   **-o (--output-dir) output\_dir** - папка, куда будут сохраняться скачанные изображения.

Пример работы со скриптом: **./grubber.rb -u coffeescript.org -o ./tmp**.

Реализация состоит из 2-х модулей и 2-х классов:

-   **Grubbers** - основной модуль, который хранит набор модулей, реализующих грабберы;
-   **Grubbers::ImageGrubber** - модуль граббера, скачивающего изображения с целевого ресурса;
-   **Grubbers::ImageGrubber::Grubber** - класс, реализующий ImageGrubber;
-   **Grubbers::ImageGrubber::ConsoleTool** - класс, реализующий парсер параметров, переданных через консоль (основан на использовании OptParse).

Для работы с **ImageGrubber::Grubber**, необходимо инициализировать его, передав ему целевой ресурс и output-директорию как стороковые парамтеры, а затем вызвать метод .grub.
Для вывода в консоль процесса скачивания, в метод .grub необходимо передать false (по умолчанию, verbose = true).

**Пример работы:**

~~~~ {.bash}
daiver@vaio ~/P/R/funbox> ruby ./scripts/grubber.rb -u http://www.advantika.ru/ -o ./tmp
DOWNLOADED: http://www.advantika.ru:80/bitrix/templates/.default/images/logo.png
DOWNLOADED: http://www.advantika.ru:80/upload/iblock/031/031f798efb6283b521734a16ce83fd9c.png
...много файлов...
DOWNLOADED: http://www.advantika.ru:80/upload/iblock/0ba/0bab74ff89b8224fe9462d691f1c1a35.png
~~~~

**Реализация**:

-   имплементация: [GitLink](https://github.com/tasksfromfb/tffb/tree/master/lib)
-   [Grubbers](https://github.com/tasksfromfb/tffb/blob/master/lib/grubbers.rb)
-   [ConsoleTool](https://github.com/tasksfromfb/tffb/blob/master/lib/grubbers/image_grubber/console_tool.rb)
-   [ImageGrubber](https://github.com/tasksfromfb/tffb/blob/master/lib/grubbers/image_grubber/grubber.rb)
-   пример использования: [GitLink](https://github.com/tasksfromfb/tffb/blob/master/scripts/grubber.rb)

* * * * *

#### Q6. Покройте код предыдущей задачи тестами (плюсом будет использование rspec).

* * * * *

Юнит-тесты вынесены в конекст Units, интеграционный тест вынесен в конекст Integration. Integration-тест реализовал запуском скрипта в отдельном процессе и сверкой его вывода с ожидаемым.

**Примечания**:

-   все тесты описаны в **./spec/image\_grubber\_spec.rb**;
-   тесты запускать командой **rspec** из корневой папки с проектом;
-   перед запуском тестов необходимо запустить тестовый сервер с веб-приложением (Sinatra, простая страничка с двумя картинками, ссылка на одну из которых - битая):

~~~~ {.ruby}
ruby ./spec/client_server/client_server.rb
~~~~

**Реализация**: [GitLink](https://github.com/tasksfromfb/tffb/tree/master/spec)

* * * * *

### LEVEL 3

* * * * *

#### Q1. У вас есть массив целых чисел. Все числа идут последовательно от 1 до k. Но в массиве пропущены 2 числа. Реализуйте алгоритм для нахождения этих чисел.

* * * * *

Для реализации я решил воспользоваться алгоритмом бинарного поиска с некоторыми апдейтами.
Суть алгоритма в постоянном рекурсивном делении массива пополам для получения двух чисел от центра массива,
между которыми будем определять разницу и, тем самым, получать недостающие числа.

***Пошагово***:

0) Определяем массив найденных чисел как пустой (в него будем запоминать найденные числа).
1) Находим середину массива (делим массив пополам):

-   если середины нет (ситуация, когда array.length = 0): переходим на **пункт 6**;
-   иначе: переходим на **пункт 2**.

2) Проверяем разницу между крайними элементами середины массива (right - left):

-   == 1: пропущенного числа нет - ничего не запоминаем;
-   == 2: пропущено 1 число - запоминаем left + 1;
-   == 3: пропущено 2 числа - запоминаем (left + 1) и (left + 2);

3) Если найдено 2 элемента: переходим на **пункт 6**
4) Берем левую половину массива и переходим на **пункт 1**;
5) Берем правую половину массива и переходим на **пункт 1**;
6) Возвращаем найденные элементы.

Возможны ситуации, при которых будет найдено 0, 1 или 2 числа. Это значит, что в исходном массиве были пропущены числа либо в начале, либо в конце, либо и в конце и в начале.
Эти элементы легко выичсляемы, т.к. нам заранее известно количество пропущенных элементов. Т.е., в набор этих чисел входят: 1, 2, (array.last + 1), (array.last + 2).
В этом случае, алгоритм не позволит найти пропущенные два числа, поэтому создадим для него "обёртку для результата":

1) Если найдено 2 элемента - поиск завершен. Иначе переходим на **пункт 2**.
2) Если найдено 0 элементов (иначе переходим на **пункт 3**):

-   если число в начале исходного массива = 2: пропущены числа 1 и (array.last + 1);
-   если число в начале исходного массива = 3: пропущены числа 1 и 2;
-   если число в начале исходного массива = 1: пропущены числа (array.last + 1) и (array.last + 2).

3) Если найден 1 элемент:

-   если число в начале исходного массива = 1: пропущено число (array.last + 1);
-   если число в начале исходного массива = 2: пропущено число 1.

***Реализация***: [GitLink](https://github.com/tasksfromfb/tffb/blob/master/scripts/miss_search.rb)

* * * * *

#### Q2. Какие нюансы в работе виртуальной машины Ruby вы знаете? Какие оптимизации над кодом можно произвести для ускорения его выполнения?

* * * * *

Я бы с удовольствием подискуссировал на эту тему после прочтения книги Ruby Under Microscope, т.к. знаний очень очень мало, а чтением этой только только начинаю заниматься.

Существуют следующие реализации Ruby: Rubinius, MRI, JRuby, RubyEnterprise, IronRuby, MacRuby (можем рабоать с Ruby на любой платформе nix/win) (и еще многие, о которых я не знаю). У каждой из них есть свои нюансы. Но остановлюсь на той, с которой работал - с оригинальной реализацией Ruby - MRI.

Я сделал маленькую выжимку из того, что я успел узнать на данный момент из следующих докладов:

-   [Профилирование и оптимизация производительности Ruby-кода](https://www.youtube.com/watch?v=gZd-nLIkqvs);
-   [Rubyc-2014 Timothy Tsvetkov: "GC in Ruby from 1.9 to 2.2"](https://www.youtube.com/watch?v=iGlcG4Oj-40);
-   [Incremental Garbage Collection in Ruby 2.2](https://engineering.heroku.com/blogs/2015-02-04-incremental-gc/).

Выжимка:

-   От версии к версии в Ruby (MRI) менялся алгоритм Garbage Collector'a. По большей части, вызывано неэффективными алгоритмами и длительными паузами выполняемой программы во время работы GC. Например, раньше, во времена Ruby 1.8 и 1.9 использовался алгоритм Mark&Sweep, который во время своего прохода по объектам паузил выполнение текущей программы. Улучшения этого алгоритма сокращало время паузы. В Ruby 2.0 и выше мы перешли на Incremental GC, дабы сократить время пауз еще больше (на самом деле, время остается темже, просто пауза разбивается на множество мелких пауз (или фаз), во время которых отрабатываются поэтапно Mark, а зетем Sweep).
-   Маленький нюанс Ruby 2.1 и 2.2, который мог "грохнуть" Rails-приложение. В Ruby 2.1 GC не удалял объекты типа Symbol, отчего была возможность DDOS'нуть Rails-приложения, генерируюя бесконечное количество Symbol-объектов, передавая специальные параметры через URL. В Ruby 2.2 GC очищает Symbol-объекты.
-   Следует строго следить за количеством выделяемых вами объектов. Это может повлечь чрезмерное использование памяти и падение производительности. Когда Ruby выделяет память под свой процесс - он её никогда не освобождает для других процессов. Он оставляет её для себя на всё время существования своего процесса.
-   В MRI присутствует GIL (Global Interpreter Lock). GIL заставляет работать в единицу времени только один поток, от этого создается впечатление, что некоторые конструкции данных потоко-безопасны. Но запуск кода на других реализациях Ruby может вас удивить. JRuby и Rubinius в данном случае могут повести себя совсем по другому, т.к. они отдают управление потоками операционной системе. ЗАТО: MRI дает нам возможность работать с потоками даже в системах, которые их не поддерживают.

Для ускорения работы можно поиграться с поведением Garbage Collector'а, изменяя его доступные параметры (все можно глянуть здесь: <https://github.com/ruby/ruby/blob/ruby_2_3/gc.c>) или вообще подменяя его другими реализациями. Описание некоторых параметров GC можно увидеть, например, здесь: (<http://helabs.com/blog/2014/12/19/ruby-gc-tuning-parameters/>).

К сожалению, я не силен в реализации Ruby, но, т.к. язык открытый, можно воспользоваться различными патчами/апдейтами для данного языка (скомпилить свою сборку). Или воспользоваться другими реализациями Ruby (JRuby, например), где вы сможете воспользоваться преимуществами выбранной реализации, а, заодно, и набором библиотек из её окружения.

* * * * *

#### Q3. Привести пример максимально быстрого алгоритма

У вас есть массив объектов (10,000,000) хранящих данные о пользователях. Поля следующие:

-   Пол (буленовское значение - 1 мужчина 0 женщина)
-   Возраст (целое число от 0 до 100)
-   Рост (целое число от 0 до 300)
-   Индекс (целое число от 0 до 1,000,000)
-   Сумма денег (с точкой от 0 до 1,000,000)

Приведите пример (реализацию на любом существующем языке программирования) максимально быстрого алгоритма для выбора объектов по определенным условиям (количество условий может быть от 1 до 5) с учетом возможности указаний диапазонов для числовых значений.

* * * * *

Я решил свести поиск по параметру к пересечению множеств соответствий (иными словами, к использованию теории множеств).

Я представил каждый параметр как коллекцию индексированных множеств, где индекс множества - это значение параметра, а само множество - набор идентификаторов объектов с соответствующим значением параметра.

В итоге получаем, что параметр - это набор множеств, и каждое множество связано с отдельным значением параметра.

**Иллюстрация**: [GitLink](https://github.com/tasksfromfb/tffb/blob/master/illustration.png)

Отдельный объект может принадлежать разным множествам согласно своим различным параметрам. Напрмер: объект со значениями {age: 10, height: 20} принадлежит множеству Age[10] и множеству Height[20].

Такая конструкция упрощает выборку и, по сути, нам не нужно искать объект в коллекции объектов с постоянным сравнением его параметров.

Нам всего лишь нужно будет просто отобрать все множества с соответствующими значениями параметров, а затем, согласно теории множеств, пересечь все найденные множества, тем самым получив номера объектов с заданными параметрами.

Если нам необходимо найти объекты по диапазону значений какого-либо параметра, нам нужно будет просто отобрать все множества с индексами, входящими в диапазон, и провести операцию объединения между найденными множествами.

* * * * *

###### Например:

* * * * *

Имеем массив объектов:

~~~~ {.ruby}
[ 0: {age: 25, height: 15},
  1: {age: 35, height: 22},
  2: {age: 25, height: 23}  ]
~~~~

Имеем связанную базу параметров и множеств:

~~~~ {.ruby}
AGE { 25 => [0,2], 35 => [1] }
HEIGHT { 15 => [0],   22 => [1], 23 => [2] }
~~~~

Теперь, для поиска всех объектов с возрастом 25, нам нужно просто взять AGE с индексом 25: AGE[25] =\> [0,2].

Если мы хотим выбрать всех людей, у которых AGE= 25 и HEIGHT= 15, мы должны будем просто выбрать нужные множества и пересечь их:

**AGE[25] & HEIGHT[15] =\> [0,2] & [0] =\> [0]** - объект с индексом 0 соотвествует объекту с параметрами AGE=25 и HEIGHT=15.

Когда мы хотим выбрать объект с параметром, соответствующим диапазону значений (например, AGE=(25..27)), мы просто выбираем все множества, индекс которых больше 25 и объединяем их.
Когда нам нужно выбрать объекты, у которых значение параметра больше определенного числа (например, HEIGHT\>150), мы просто сводим этот поиск к поиску по диапазону (150..300), т.к. конечное значение HEIGHT нам уже известно.

Как видим, операция поиска полностью свелась к выбору нужных множеств и к операциям над ними, тем самым получая идентификаторы нужных объектов напрямую.
Иными словами, сразу берем то, что нам нужно :)

***Реализация***:

-   имплементация: [GitLink](https://github.com/tasksfromfb/tffb/tree/master/lib)

    -   [LazyDataSet](https://github.com/tasksfromfb/tffb/blob/master/lib/search_engine/LazyDataSet.rb)
    -   [SearchModule](https://github.com/tasksfromfb/tffb/blob/master/lib/search_engine.rb)
    -   [Searcher](https://github.com/tasksfromfb/tffb/blob/master/lib/search_engine/Searcher.rb)
    -   [FloatySearcher](https://github.com/tasksfromfb/tffb/blob/master/lib/search_engine/FloatySearcher.rb)
-   пример использования: [GitLink](https://github.com/tasksfromfb/tffb/blob/master/scripts/searcher.rb)

Имеем:

-   Массив объектов с различными параметрами sex, age, height, index, salary;
-   На этапе заполнения массива мы заполнили коллекции множеств соответствующим id;
-   Коллекции множеств: Sex, Age, Height, Index, Salary.

Инструмент поиска представлен классами LazyDataSet, Searcher, FloatySearcher и SearchMachine, где:

-   **LazyDataSet** - имплементация отдельного параметра как пула индексированных множеств (объектов Set). Регистрирует в себе минимальное и максимальное значение параметра (диапазон значений параметра). Каждый индекс - отдельное значение параметра. Множество, связанное с этим индексом - коллекция id объектов, которые имеют соответствующее значение параметра. Lazy - множества инициализируются тогда, когда они нужны.
-   **Searcher** - имплементирует базовую логику выборки и пересечения множеств. Аггрегирует в себе контекст (просто имя описываемого параметра) и LazyDataSet (связанный параметр);
-   **FloatySearcher** - расширение Searcher для работы с Float-значениями параметров;
-   **SearchMachine** - пул серчеров (а отсюда и гибкость: можем регистрировать любое количество сёрчеров динамически). Имплементирует систему выборки множеств по набору значений параметров. Аггрегирует в себе массив Searcher'ов и результат выборки (Set). Для выбора множества по определенному параметру просто делегирует выборку нужному Searcher'у, сохраняя результат в своем внутреннем параметре @result.

Иными словами: есть SearchMachine, он регестрирует в себе набор серчеров, выборку делегирует отдельно выбранному серчеру (согласн оконексту), накапливает в себе результаты и вовзращает их по запросу.

Для работы с моей имплементацией и решения текущей задачи:

1) Создаем необходимые сёрчеры с привязанными параметрами (LazyDataSet) и контекстами (:sex, :age, :height, :index, :salary):

~~~~ {.ruby}
sex_searcher    = Searcher.new(:sex,    LazyDataSet.new(min: 0, max: 1))
age_searcher    = Searcher.new(:age,    LazyDataSet.new(min: 0, max: 100))
height_searcher = Searcher.new(:height, LazyDataSet.new(min: 0, max: 300))
index_searcher  = Searcher.new(:index,  LazyDataSet.new(min: 0, max: 1_000_000))
salary_searcher = FloatySearcher.new(:salary, LazyDataSet.new(min: 0.0, max: 1_000_000.0))
~~~~

2) В момент заполнения массива объектами заносим данные в LazyDataSet'ы, которые аггрегурют соответствующие сёрчеры:

~~~~ {.ruby}
sex_searcher.data_set[parameter_value]    << object_index
age_searcher.data_set[parameter_value]    << object_index
height_searcher.data_set[parameter_value] << object_index
index_searcher.data_set[parameter_value]  << object_index
salary_searcher.data_setparameter_value]  << object_index
~~~~

3) Создаем SearchMachine и регестриуем в нём созданные сёрчеры:

~~~~ {.ruby}
search_machine = Search.machine.new

search_engine.register_searcher(sex_searcher)
search_engine.register_searcher(age_searcher)
search_engine.register_searcher(height_searcher)
search_engine.register_searcher(index_searcher)
search_engine.register_searcher(salary_searcher)
~~~~

Теперь, для выбора объектов с параметром :age равным 30, нам необходимо вызвать метод select\_by с Hash-параметром со следующими ключами:

-   **:context** - контекст выборки (sex, age, height, etc);
-   **:action** - операция выборки (= \> \< \>= \<= (+диапазоны с двумя условиями: \<\< \<=\< \<\<= \<=\<=));
-   **:value** - значение параметра, по которому ведем выборку (число или Ruby-диапазон).

~~~~ {.ruby}
result = search_engine.select_by(context: :age, action: '=', value: 30).get_result
~~~~

Для выбора объектов по множеству параметров и значений (почти наихудший случай, который заставит, вероятно, выбрать чуть ли не все объекты):

Выбрать всех женщин в возрасте от 30 до 55 лет включительно, чей рост выше 1 единицы, индекс менее 900\_00 и с зарплатой больше 1 рублика.

~~~~ {.ruby}
search_engine
  .select_by(context: :sex,    action: '=',    value: 0)
  .select_by(context: :age,    action: '<=<=', value: 30..55)
  .select_by(context: :height, action: '>',    value: 1)
  .select_by(context: :index,  action: '<',    value: 900_000)
  .select_by(context: :salary, action: '>',    value: 1)
  .get_result
~~~~

Эта выборка на моем компьютере в среднем занимает 10-15 секунд. Максимальная скорость у операции '=' (т.к. просто берется нужное значение напрямую без обходов).
В результате имеем идентификаторы объектов, которые соответствуют нужным нам параметрам, и мы может спокойно выбрать их и работать с ними.

Не думаю, что Ruby - лучший язык для реализации таких вычислений, т.к. в моем подходе производится много затратных по памяти вычислений (общее время Set\#merge довольно велико, если было отобрано over9000 множеств).
Но в целом, считаю, что мой подход (именно подход) быстрее простого перебора всех объектов по условию, т.к. в моем случае у нас нет необходимости перебирать все объекты, а скорость вычислений зависит от реализации в выбранном языке Set-структуры и реализации самой системы поиска (выбора и пересечения множеств).

**Примечание**: в своем примере исходный массив объектов генерировал как простой набор хэшей. 10\_000\_000 элементов на моем компьютере генерируются очень долго (всю память выжрало, всё зависало и я просто напросто не дождался), поэтому я ограничился 1 миллионом объектов (на инициализацию уходит \~22 секунды).

**Ограничения и дополнения в реализации**\*:

-   удаление элемента из массива грозит полным переопределением всех множеств параметров.
-   решение предыдущего момента: в исходном массиве не удалять элементы, а "занулять" их; в серчерах удалять наличие этого элемента в LazyDataSet'е. Или переопределять все множества О.О
-   дополнения: в будущем можно по-профайлить код, посмотреть, где производится наибольшее количество вызовов, где тратится больше всего памяти и порефакторить код, повысив performance.

**Возможные улучшения**: подумать, как можно сократить количество операций пересечения множеств. Например, разобраться, как объединять отдельные множества в одно надмножество без необходимости его копирования (вероятнее всего, следует покопаться в теории графов, я пока не силен в этом).

* * * * *
