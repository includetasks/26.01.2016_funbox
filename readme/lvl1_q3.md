#### Q3. Вы когда-нибудь писали в функциональном стиле на Ruby? Если да, то какие сильные и слабые стороны есть у данного подхода?

---

В функциональном стиле особо (за исключением повсеместного использования блоков и местами lambda) не писал (только пробовал, когда вникал в эту тему). Почитал об этом в различных статьях на habrahabr и Wikipedia, а так же немного в книгах, и могу сказать следующее:

В отношении Ruby:

- Ruby почти повсеместно использует свойство функционального программирования - это функции высшего порядка (блоки кода, передаваемые функции как параметр и выполняемые через инструкцию yield) (proc, lambda).
- Слабая сторона, наверно, только в неочевидности алгоритмов кода (мозг привык думать императивно/декларативно + различное поведение return у proc, lambda и method могут породить неочевидные поведения функций).
- Сильная сторона: поддержка функционального стиля программирования как такового (хоть и частичная, т.к. Ruby - ООП-язык; возможность дополнять / изменять алгоритмы работы методов за счет блоков (proc / lambda / method), которые играют роль callback-функций в таком контексте; поддержка ленивых вычислений (lambda, proc)).

Преимущества функционального подхода в целом для программирования:

- отладка: т.к. состояние впринципе неизменяемое, а функции - чистые и без побочных эффектов, можно легко локализовать проблему на основе аргументов и реализации функции;
- многопоточность / асинхронность: нет mutex'ов (т.к. нет разделяемого состояния) => можно легко распаралеллить выполнение функций;
- оптимизация за счет ленивых вычислений: например, когда мы вычисляем одну функцию функцию, зависящую от результатов выполнения (допустим, двух предыдущих вызовов других функций, который выполняются только вместе с нашей первой функцией), умный компилятор поймет, что выполнять вычесления этих двух функций нужно только на этапе обращеня к ним в последней функции, в которй они выполняют роль параметров (отсюда преимущество в функциях высшего порядка).

Недостатки функционального подхода в целом для программирования:

- чистота функций: в программах очень часто необходимо работать, изменяя внешнее состояние (например, консольное приложение, выводящая результаты на экран), а функции в этих программах при одних и тех же входных параметрах могут возвращать различные значения из-за непостоянного внешнего состояния. Исхитрение: гнать состояние от функции к функции;
- т.к. функции чистые, мы не имеем возможности организовать последовательность их вычислений (если компилятор умный => он распараллелит их выполнение), но можно исхитриться передачей функций как параметров (правда, получив при этом callback hell). 

В отношении функционального подхода в целом, пока основными плюсами для себя выделил чистые функции, функции высшего порядка и ленивые вычисления.
Минус пока вижу в постоянных "играх с памятью": при копировании и удалении состояний (параметров функций) нужнен эффективный Garbage Collector, который хорошо бы справлялся с постоянным выделением и очисткой памяти ИЛИ (там где нет автоматического сборщика мусора) самому грамотно следить за тем, чтобы память "не текла".

---
