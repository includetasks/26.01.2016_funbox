#### Q2. Какие нюансы в работе виртуальной машины Ruby вы знаете? Какие оптимизации над кодом можно произвести для ускорения его выполнения?

---

Я бы с удовольствием подискуссировал на эту тему после прочтения крутой книги Ruby Under Microscope, т.к. знаний очень очень мало, а чтением этой только только начинаю заниматься.

Существуют следующие реализации Ruby: Rubinius, MRI, JRuby, RubyEnterprise, IronRuby, MacRuby (можем рабоать с Ruby на любой платформе nix/win). У каждой из них есть свои нюансы. Но остановлюсь на той, с которой работал - с оригинальной реализацией Ruby - MRI.

Я сделал маленькую выжимку из того, что я успел узнать на данный момент из следующих докладов:
- [Профилирование и оптимизация производительности Ruby-кода](https://www.youtube.com/watch?v=gZd-nLIkqvs);
- [Rubyc-2014 Timothy Tsvetkov: "GC in Ruby from 1.9 to 2.2"](https://www.youtube.com/watch?v=iGlcG4Oj-40);
- [Incremental Garbage Collection in Ruby 2.2](https://engineering.heroku.com/blogs/2015-02-04-incremental-gc/).

Выжимка:

- От версии к версии в Ruby (MRI) менялся алгоритм Garbage Collector'a. По большей части, вызывано неэффективными алгоритмами и длительными паузами выполняемой программы во время работы GC. Например, раньше, во времена Ruby 1.8 и 1.9 использовался алгоритм Mark&Sweep, который во время своего прохода по объектам паузил выполнение текущей программы. Улучшения этого алгоритма сокращало время паузы. В Ruby 2.0 и выше мы перешли на Incremental GC, дабы сократить время пауз еще больше (на самом деле, время остается темже, просто пауза разбивается на множество мелких пауз (или фаз), во время которых отрабатываются поэтапно Mark, а зетем Sweep).
- Маленький нюанс Ruby 2.1 и 2.2, который мог "грохнуть" Rails-приложение. В Ruby 2.1 GC не удалял объекты типа Symbol, отчего была возможность DDOS'нуть Rails-приложения, генерируюя бесконечное количество Symbol-объектов, передавая специальные параметры через URL. В Ruby 2.2 GC очищает Symbol-объекты.
- Следует строго следить за количеством выделяемых вами объектов. Это может повлечь чрезмерное использование памяти и падение производительности. Когда Ruby выделяет память под свой процесс - он её никогда не освобождает для других процессов. Он оставляет её для себя на всё время существования своего процесса.
- В MRI присутствует GIL (Global Interpreter Lock). GIL заставляет работать в единицу времени только один поток, от этого создается впечатление, что некоторые конструкции данных потоко-безопасны. Но запуск кода на других реализациях Ruby может вас удивить. JRuby и Rubinius в данном случае могут повести себя совсем по другому, т.к. они отдают управление потоками операционной системе. ЗАТО: MRI дает нам возможность работать с потоками даже в системах, которые их не поддерживают. 

Для ускорения работы можно поиграться с поведением Garbage Collector'а, изменяя его доступные параметры (все можно глянуть здесь: https://github.com/ruby/ruby/blob/ruby_2_3/gc.c) или вообще подменяя его другими реализациями. Описание некоторых параметров GC можно увидеть здесь: (http://helabs.com/blog/2014/12/19/ruby-gc-tuning-parameters/).

К сожалению, я не силен в реализации Ruby, но, т.к. язык открытый, можно воспользоваться различными патчами/апдейтами для данного языка (скомпилить свою сборку). Или воспользоваться другими реализациями Ruby (JRuby, например), где вы сможете воспользоваться преимуществами выбранной реализации, а, заодно, и набором библиотек из её окружения.

---