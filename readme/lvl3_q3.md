#### Q3. Привести пример максимально быстрого алгоритма

У вас есть массив объектов (10,000,000) хранящих данные о пользователях. Поля следующие:

- Пол (буленовское значение - 1 мужчина 0 женщина)
- Возраст (целое число от 0 до 100)
- Рост (целое число от 0 до 300)
- Индекс (целое число от 0 до 1,000,000)
- Сумма денег (с точкой от 0 до 1,000,000)

Приведите пример (реализацию на любом существующем языке программирования) максимально быстрого алгоритма для выбора объектов по определенным условиям (количество условий может быть от 1 до 5) с учетом возможности указаний диапазонов для числовых значений.

---

Я решил свести поиск по параметру к пересечению множеств соответствий (иными словами, к использованию теории множеств).

Я представил каждый параметр как коллекцию индексированных множеств, где индекс множества - это значение параметра, а само множество - набор идентификаторов объектов с соответствующим значением параметра.

В итоге получаем, что параметр - это набор множеств, и каждое множество связано с отдельным значением параметра.

**Иллюстрация**:

Отдельный объект может принадлежать разным множествам согласно своим различным параметрам. Напрмер: объект со значениями {age: 10, height: 20} принадлежит множеству Age[10] и множеству Height[20].

Такая конструкция упрощает выборку и, по сути, нам не нужно искать объект в коллекции объектов с постоянным сравнением его параметров.

Нам всего лишь нужно будет просто отобрать все множества с соответствующими значениями параметров, а затем, согласно теории множеств, пересечь все найденные множества, тем самым получив номера объектов с заданными параметрами.

Если нам необходимо найти объекты по диапазону значений какого-либо параметра, нам нужно будет просто отобрать все множества с индексами, входящими в диапазон, и провести операцию объединения между найденными множествами.

---

###### Например:

---

Имеем массив объектов:

```ruby
[ 0: {age: 25, height: 15},
  1: {age: 35, height: 22},
  2: {age: 25, height: 23}  ]
```

Имеем связанную базу параметров и множеств:

```ruby
AGE { 25 => [0,2], 35 => [1] }
HEIGHT { 15 => [0],   22 => [1], 23 => [2] }
```

Теперь, для поиска всех объектов с возрастом 25, нам нужно просто взять AGE с индексом 25: AGE[25] => [0,2].

Если мы хотим выбрать всех людей, у которых AGE= 25 и HEIGHT= 15, мы должны будем просто выбрать нужные множества и пересечь их:

**AGE[25] & HEIGHT[15] => [0,2] & [0] => [0]** - объект с индексом 0 соотвествует объекту с параметрами AGE=25 и HEIGHT=15.

Когда мы хотим выбрать объект с параметром, соответствующим диапазону значений (например, AGE=(25..27)), мы просто выбираем все множества, индекс которых больше 25 и объединяем их.
Когда нам нужно выбрать объекты, у которых значение параметра больше определенного числа (например, HEIGHT>150), мы просто сводим этот поиск к поиску по диапазону (150..300), т.к. конечное значение HEIGHT нам уже известно.

Как видим, операция поиска полностью свелась к выбору нужных множеств и к операциям над ними, тем самым получая идентификаторы нужных объектов напрямую.
Иными словами, сразу берем то, что нам нужно :)

***Реализация***:

- имплементация: [GitLink](https://github.com/tasksfromfb/tffb/tree/master/lib)
  - [LazyDataSet](https://github.com/tasksfromfb/tffb/blob/master/lib/search_engine/LazyDataSet.rb)
  - [SearchModule](https://github.com/tasksfromfb/tffb/blob/master/lib/search_engine.rb)
  - [Searcher](https://github.com/tasksfromfb/tffb/blob/master/lib/search_engine/Searcher.rb)
  - [FloatySearcher](https://github.com/tasksfromfb/tffb/blob/master/lib/search_engine/FloatySearcher.rb)
- пример использования: [GitLink](https://github.com/tasksfromfb/tffb/blob/master/scripts/searcher.rb)

Имеем:

- Массив объектов с различными параметрами sex, age, height, index, salary;
- На этапе заполнения массива мы заполнили коллекции множеств соответствующим id;
- Коллекции множеств: Sex, Age, Height, Index, Salary.

Инструмент поиска представлен классами LazyDataSet, Searcher, FloatySearcher и SearchMachine, где:

- **LazyDataSet**    - имплементация отдельного параметра как пула индексированных множеств (объектов Set). Регистрирует в себе минимальное и максимальное значение параметра (диапазон значений параметра). Каждый индекс - отдельное значение параметра. Множество, связанное с этим индексом - коллекция id объектов, которые имеют соответствующее значение параметра.
- **Searcher**       - имплементирует базовую логику выборки и пересечения множеств. Аггрегирует в себе контекст (просто имя описываемого параметра) и LazyDataSet (связанный параметр);
- **FloatySearcher** - расширение Searcher для работы с Float-значениями параметров;
- **SearchMachine**  - пул серчеров (а отсюда и гибкость: можем регистрировать любое количество сёрчеров динамически). Имплементирует систему выборки множеств по набору значений параметров. Аггрегирует в себе массив Searcher'ов и результат выборки (Set). Для выбора множества по определенному параметру просто делегирует выборку нужному Searcher'у, сохраняя результат в своем внутреннем параметре @result.

Иными словами: есть SearchMachine, он регестрирует в себе набор серчеров, выборку делегирует отдельно выбранному серчеру (согласн оконексту), накапливает в себе результаты и вовзращает их по запросу.

Для работы с моей имплементацией и решения текущей задачи:

1) Создаем необходимые сёрчеры с привязанными параметрами (LazyDataSet) и контекстами (:sex, :age, :height, :index, :salary):

```ruby
sex_searcher    = Searcher.new(:sex,    LazyDataSet.new(min: 0, max: 1))
age_searcher    = Searcher.new(:age,    LazyDataSet.new(min: 0, max: 100))
height_searcher = Searcher.new(:height, LazyDataSet.new(min: 0, max: 300))
index_searcher  = Searcher.new(:index,  LazyDataSet.new(min: 0, max: 1_000_000))
salary_searcher = FloatySearcher.new(:salary, LazyDataSet.new(min: 0.0, max: 1_000_000.0))
```

2) В момент заполнения массива объектами заносим данные в LazyDataSet'ы, которые аггрегурют соответствующие сёрчеры:

```ruby
sex_searcher.data_set[parameter_value]    << object_index
age_searcher.data_set[parameter_value]    << object_index
height_searcher.data_set[parameter_value] << object_index
index_searcher.data_set[parameter_value]  << object_index
salary_searcher.data_setparameter_value]  << object_index
```

3) Создаем SearchMachine и регестриуем в нём созданные сёрчеры:

```ruby
search_machine = Search.machine.new

search_engine.register_searcher(sex_searcher)
search_engine.register_searcher(age_searcher)
search_engine.register_searcher(height_searcher)
search_engine.register_searcher(index_searcher)
search_engine.register_searcher(salary_searcher)
```

Теперь, для выбора объектов с параметром :age равным 30, нам необходимо вызвать метод select_by с Hash-параметром со следующими ключами:

- **:context** - контекст выборки (sex, age, height, etc);
- **:action** - операция выборки (= > < >= <= (+диапазоны с двумя условиями: << <=< <<= <=<=));
- **:value** - значение параметра, по которому ведем выборку (число или Ruby-диапазон).

```ruby
result = search_engine.select_by(context: :age, action: '=', value: 30).get_result
```

Для выбора объектов по множеству параметров и значений (почти наихудший случай, который заставит, вероятно, выбрать чуть ли не все объекты):

Выбрать всех женщин в возрасте от 30 до 55 лет включительно, чей рост выше 1 единицы, индекс менее 900_00 и с зарплатой больше 1 рублика.

```ruby
search_engine
  .select_by(context: :sex,    action: '=',    value: 0)
  .select_by(context: :age,    action: '<=<=', value: 30..55)
  .select_by(context: :height, action: '>',    value: 1)
  .select_by(context: :index,  action: '<',    value: 900_000)
  .select_by(context: :salary, action: '>',    value: 1)
  .get_result
```
  
Эта выборка на моем компьютере в среднем занимает 10-15 секунд. Максимальная скорость у операции '=' (т.к. просто берется нужное значение напрямую без обходов).
В результате имеем идентификаторы объектов, которые соответствуют нужным нам параметрам, и мы может спокойно выбрать их и работать с ними.

Не думаю, что Ruby - лучший язык для реализации таких вычислений, т.к. в моем подходе производится много затратных по памяти вычислений (общее время Set#merge довольно велико, если было отобрано over9000 множеств).
Но в целом, считаю, что мой подход (именно подход) быстрее простого перебора всех объектов по условию, т.к. в моем случае у нас нет необходимости перебирать все объекты, а скорость вычислений зависит от реализации в выбранном языке Set-структуры и реализации самой системы поиска.

**Примечание**: в своем примере исходный массив объектов генерировал как простой набор хэшей. 10_000_000 элементов на моем компьютере генерируются очень долго (всю память выжрало, всё зависало и я просто напросто не дождался), поэтому я ограничился 1 миллионом объектов (на инициализацию уходит ~22 секунды).

**Ограничения и дополнения в реализации***:

- удаление элемента из массива грозит полным переопределением всех множеств параметров.
- решение предыдущего момента: в исходном массиве не удалять элементы, а "занулять" их; в серчерах удалять наличие этого элемента в LazyDataSet'е. Или переопределять все множества О.О
- дополнения: в будущем можно по-профайлить код, посмотреть, где производится наибольшее количество вызовов, где тратится больше всего памяти и порефакторить код, повысив performance.

---